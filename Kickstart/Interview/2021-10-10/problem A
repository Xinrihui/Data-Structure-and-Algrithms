

Q1:

There is a street, and along it there are tiles of land with some prices. For example:

[3, 2, 3, 1, 4, 1, 1, 3] (million dollars)

Now you have some budget, for example 7 (million dollars), I want you to buy the longest possible segment of land within that budget

In the example, the longest is [1, 4, 1, 1]

Int GetLongestSegment(std::vector<int> prices, int budget) {
}


Find O(n) solution


关键: 连续的子区间, 即子区间只要向右边滑动 (滑动窗口问题)


eg1.

budget: 7

  0  1  2  3  4  5  6  7
  3  2  3 [1  4  1  1] 3

eg2.

budget: 7
  0  1   2  3
  1  8  [2  2]


eg3.

budget: 7

0
8


M2:
Sliding window.
Increase or move

[3] 2 3 1 4 1 1 3


Q2: 找到最大的子正方形, 返回子正方形的边长, 正方形区域的和要小于等于 Budget

Find O(n ^ 2) solution

eg1.

Budget: 7

7   8   9
3  [1   2
3   2   1]

1 2
2 1
加起来是6

eg2.

Budget: 9

7  8  8  1  1
3  6 [1  1  1
3  2  1  1  1
0  0  1  1  1]
0  0  0  0  9

1 1 1
1 1 1
1 1 1
加起来是9





